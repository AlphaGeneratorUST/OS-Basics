Cython的基本知识

1）基本概念：
常规Python函数，运行时间559 ns
Cython def函数，声明一个Python函数，既可以在模块内调用，也可以在模块外调用。模块内运行时间524.2 ns，模块外运行时间512 ns：
%%cython
def f1(x):
    return x ** 2 - x
    
Cython cpdef函数，声明一个C函数和一个Python wrapper，在模块内被当做C函数调用，在模块外被.py文件当做Python函数调用。模块内运行时间43.7 ns，模块外运行时间81.7 ns:
%%cython
cpdef long f1(long x):
    return x ** 2 - x
    
Cython cdef函数，声明一个C函数，不可以在模块外被Python调用。模块内运行时间34.8 ns
%%cython
cdef long f1(long x):
    return x ** 2 - x

2) 使用C标准库替代Python的math模块：
cdef extern from "math.h":
    float cosf(float theta)
    float sinf(float theta)
    float acosf(float theta)
    
3) Cython编译：
对于Windows系统，.pyx -> .pyd
转换动态类型的Python版本为静态类型的Cython版本


# Cython type inference

To enable type inference for a function, we can use the decorator form of infer_types:
cimport cython
@cython.infer_types(True)
def more_inference():
    i = 1
    d = 2.0
    c = 3+4j
    r = i * d + c
    return r
    
from cython cimport operator
print operator.dereference(p_double)
# => 1.618

cdef st_t *p_st = make_struct()
cdef int a_doubled = p_st.a + p_st.a

def integrate(a, b, f):
    cdef int i
    cdef int N=2000
    cdef float dx, s=0.0
    dx = (b-a)/N
    for i in range(N):
    s += f(a+i*dx)
    return s * dx

def integrate(a, b, f):
    cdef:
    int i
    int N=2000
    float dx, s=0.0
    # ...

cdef list particles, modified_particles
cdef dict names_from_particles
cdef str pname
cdef set unique_particles

cdef long c_fact(long n):
    """Computes n!"""
    if n <= 1:
    return 1
    return n * c_fact(n - 1)

cpdef long cp_fact(long n):
    """Computes n!"""
    if n <= 1:
    return 1
    return n * cp_fact(n - 1)

cdef int *ptr_i = <int*>v

def print_address(a):
    cdef void *v = <void*>a
    cdef long addr = <long>v
    print "Cython address:", addr
    print "Python id :", id(a)

cdef struct mycpx:
    float real
    float imag
    
cdef union uu:
    int a
    short b, c

ctypedef struct mycpx:
    float real
    float imag

ctypedef union uu:
    int a
    short b, c

ctypedef double real
ctypedef long integral

def displacement(real d0, real v0, real a, real t):
    """Calculates displacement under constant acceleration."""
    cdef real d = d0 + (v0 * t) + (0.5 * a * t**2)
    return d

cdef unsigned int i, n = 100
    for i in range(n):
    # ...

cdef int i, N
for i in range(N):
    a[i] = i + 1

cdef unsigned int i, n = len(a) - 1
for i in range(1, n):
    a[i] = (a[i-1] + a[i] + a[i+1]) / 3.0

from distutils.core import setup
from Cython.Build import cythonize

setup(name="nbody", ext_modules=cythonize("nbody.pyx"))

cdef class Particle:
    """Simple Particle extension type."""
    cdef public double mass
    cdef readonly double position
    cdef double velocity
    # ...

cdef class Matrix:
    cdef:
        unsigned int nrows, ncols
        double *_matrix
    def __cinit__(self, nr, nc):
        self.nrows = nr
        self.ncols = nc
        self._matrix = <double*>malloc(nr * nc * sizeof(double))
        if self._matrix == NULL:
            raise MemoryError()

cdef class Particle:
    """Simple Particle extension type."""
    cdef double mass, position, velocity
    # ...
    cpdef double get_momentum(self):
        return self.mass * self.velocity

def add_momentums_typed(list particles):
    """Returns the sum of the particle momentums."""
    cdef:
        double total_mom = 0.0
        Particle particle
    for particle in particles:
        total_mom += particle.get_momentum()
    return total_mom

cdef class CParticle(Particle):
    cdef double momentum
    def __init__(self, m, p, v):
        super(CParticle, self).__init__(m, p, v)
        self.momentum = self.mass * self.velocity
    cpdef double get_momentum(self):
        return self.momentum

from libc.stdlib cimport rand, srand, qsort, malloc, free
cdef int *a = <int*>malloc(10 * sizeof(int))

from libc.string cimport memcpy as c_memcpy

from libcpp.vector cimport vector
cdef vector[int] *vi = new vector[int](10)

from libc.math cimport sin as csin
from math import sin as pysin

cdef extern from "header.h":
    double M_PI
    float MAX(float a, float b)
    double hypot(double x, double y)
    ctypedef int integral
    ctypedef double real
    void func(integral a, integral b, real c)
    real *func_arrays(integral[] i, integral[][10] j, real **k)
    
from distutils.core import setup, Extension
from Cython.Build import cythonize
ext = Extension("mt_random",
sources=["mt_random.pyx", "mt19937ar.c"])
setup(name="mersenne_random", ext_modules = cythonize([ext]))

from distutils.core import setup, Extension
from Cython.Build import cythonize
ext = Extension("RNG",
sources=["RNG.pyx", "mt19937.cpp"],

from cython cimport boundscheck, wraparound
@boundscheck(False)
@wraparound(False)
def calc_julia(...):
    # ...

from distutils.core import setup
from Cython.Build import cythonize
setup(name="julia", ext_modules=cythonize("julia.pyx"))



from cython.parallel cimport prange

def calc_julia(...):
    # ...
    with nogil:
        for i in prange(resolution + 1):
            real = -bound + i * step
            for j in range(resolution + 1):
                # ...
    # ...

def calc_julia(...):
    # ...
    for i in prange(resolution + 1, nogil=True):
        real = -bound + i * step
        for j in range(resolution + 1):
            # ...





